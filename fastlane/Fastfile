# ClickIt Fastlane Configuration
# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools

# Suppress warnings and analytics
opt_out_usage
skip_docs

default_platform(:mac)

# Global configuration
APP_NAME = "ClickIt"
BUNDLE_ID = "com.jsonify.ClickIt"
DIST_DIR = "dist"

platform :mac do
  desc "Setup Xcode project and development environment"
  lane :setup do
    Dir.chdir("..") do
      UI.message("üîß Setting up ClickIt development environment...")
      
      # Generate Xcode project if it doesn't exist
      unless File.exist?("ClickIt.xcodeproj/project.pbxproj")
        UI.message("üì¶ Generating Xcode project...")
        sh("./generate_xcode_project.sh")
      else
        UI.message("‚úÖ Xcode project already exists")
      end
      
      # Setup Xcode path if needed
      if File.exist?("setup_xcode_path.sh")
        UI.message("üîß Configuring Xcode developer path...")
        sh("./setup_xcode_path.sh")
      end
    end
    UI.success("Setup completed! üéâ")
    UI.message("üí° Open in Xcode: open ClickIt.xcodeproj")
  end

  desc "Build ClickIt app (Debug)"
  lane :build_debug do
    Dir.chdir("..") do
      sh("./build_app_unified.sh debug")
    end
    UI.success("Debug build completed! üéâ")
    UI.message("App location: dist/ClickIt.app")
  end

  desc "Build ClickIt app (Release)"
  lane :build_release do
    Dir.chdir("..") do
      sh("./build_app_unified.sh release")
    end
    UI.success("Release build completed! üöÄ")
    UI.message("App location: dist/ClickIt.app")
  end

  desc "Build ClickIt app using Xcode (better permissions handling)"
  lane :build_xcode do
    Dir.chdir("..") do
      sh("./build_app_unified.sh release xcode")
    end
    UI.success("Xcode build completed! üéØ")
    UI.message("App location: dist/ClickIt.app")
    UI.message("üí° This build has better permissions and entitlements handling")
  end

  desc "Build and run ClickIt app"
  lane :launch do
    build_debug
    Dir.chdir("..") do
      sh("./run_clickit_unified.sh app")
    end
    UI.success("ClickIt launched! üñ±Ô∏è")
  end

  desc "Clean build artifacts"
  lane :clean do
    UI.message("Cleaning build artifacts...")
    Dir.chdir("..") do
      sh("rm -rf dist/*")
    end
    sh("rm -rf ~/Library/Developer/Xcode/DerivedData/ClickIt-*") rescue nil
    UI.success("Clean completed! üßπ")
  end

  desc "Verify code signing status"
  lane :verify_signing do
    Dir.chdir("..") do
      app_path = "dist/ClickIt.app"
      
      if File.exist?(app_path)
        UI.message("Checking code signing status...")
        
        begin
          sh("codesign --verify --verbose '#{app_path}'")
          UI.success("‚úÖ App is properly code signed")
        rescue
          UI.important("‚ö†Ô∏è  App is not code signed or signature is invalid")
        end
        
        # Show certificate info
        begin
          result = sh("codesign -dv '#{app_path}' 2>&1", log: false)
          UI.message("Code signing details:")
          UI.message(result)
        rescue
          UI.error("Could not retrieve signing details")
        end
      else
        UI.error("App not found at #{app_path}. Build first with 'fastlane build_debug' or 'fastlane build_release'")
      end
    end
  end

  desc "Show app bundle information"
  lane :info do
    Dir.chdir("..") do
      app_path = "dist/ClickIt.app"
      
      if File.exist?(app_path)
        UI.header("ClickIt App Bundle Information")
        
        # App size
        size = sh("du -sh '#{app_path}' | cut -f1", log: false).strip
        UI.message("üì¶ Bundle size: #{size}")
        
        # Version info from Info.plist
        begin
          version = sh("plutil -extract CFBundleShortVersionString xml1 -o - '#{app_path}/Contents/Info.plist' | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'", log: false).strip
          build = sh("plutil -extract CFBundleVersion xml1 -o - '#{app_path}/Contents/Info.plist' | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'", log: false).strip
          UI.message("üè∑Ô∏è  Version: #{version} (#{build})")
        rescue
          UI.message("Could not read version information")
        end
        
        # Architectures
        begin
          archs = sh("lipo -info '#{app_path}/Contents/MacOS/ClickIt' 2>/dev/null || file '#{app_path}/Contents/MacOS/ClickIt'", log: false)
          UI.message("üèóÔ∏è  Architecture: #{archs.strip}")
        rescue
          UI.message("Could not determine architecture")
        end
        
        # Permissions check
        UI.message("üîí Required permissions:")
        UI.message("   ‚Ä¢ Accessibility (for mouse events)")
        UI.message("   ‚Ä¢ Screen Recording (for window detection)")
      else
        UI.error("App not found at #{app_path}. Build first with 'fastlane build_debug' or 'fastlane build_release'")
      end
    end
  end

  desc "Full release workflow"
  lane :release do
    UI.header("Starting ClickIt Release Workflow")
    
    # Clean first
    clean
    
    # Build release version
    build_release
    
    # Verify signing
    verify_signing
    
    # Show final info
    info
    
    UI.success("üéâ Release workflow completed!")
    UI.message("Your app is ready at: dist/ClickIt.app")
    UI.message("Next steps:")
    UI.message("  ‚Ä¢ Test the app thoroughly")
    UI.message("  ‚Ä¢ Consider notarization for distribution")
    UI.message("  ‚Ä¢ Package into DMG if needed")
  end

  desc "Development workflow"
  lane :dev do
    UI.header("Starting ClickIt Development Workflow")
    
    # Build debug and run
    launch
    
    UI.success("Development session started! üõ†Ô∏è")
    UI.message("The app should now be running")
  end

  # Advanced release lanes for future use
  desc "Build ClickIt for local development and testing"
  lane :local do
    UI.header "üî® Building ClickIt for Local Development"
    
    # Build the app bundle
    build_release
    
    UI.success "‚úÖ Local build complete!"
    UI.message "üìÇ Location: #{DIST_DIR}/#{APP_NAME}.app"
    UI.message "üöÄ Launch with: open \"#{DIST_DIR}/#{APP_NAME}.app\""
  end

  desc "Create beta release on staging branch with beta-* tag"
  lane :beta do
    UI.header "üöÄ Creating Beta Release"
    
    # Use Makefile beta workflow (includes validation, build, and GitHub release)
    Dir.chdir("..") do
      sh("make beta")
    end
    
    UI.success "‚úÖ Beta release created!"
    UI.message "Check your GitHub releases for the beta"
  end

  desc "Create production release on main branch with v* tag"
  lane :prod do
    UI.header "üéâ Creating Production Release"
    
    # Use Makefile prod workflow (includes validation, build, and GitHub release)
    Dir.chdir("..") do
      sh("make prod")
    end
    
    UI.success "‚úÖ Production release created!"
    UI.message "Your production release is now live on GitHub"
  end

  # Automated tagging lanes
  desc "Create and publish automated beta release with auto-generated tag"
  lane :auto_beta do |options|
    UI.header "ü§ñ Automated Beta Release"
    
    # Ensure we're in the project root (handle both cases: called from fastlane/ or project root)
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      # Validate we're on staging branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "staging"
        UI.user_error!("‚ùå Auto beta releases must be created from 'staging' branch. Current: #{current_branch}")
      end
      
      # Check for uncommitted changes
      git_status = sh("git status --porcelain", log: false).strip
      unless git_status.empty?
        UI.user_error!("‚ùå You have uncommitted changes. Please commit or stash them first.")
      end
      
      # Generate beta tag
      timestamp = Time.now.strftime("%Y%m%d%H%M")
      version = options[:version] || "1.0.0"
      beta_tag = "beta-v#{version}-#{timestamp}"
      
      UI.message "üè∑Ô∏è  Creating tag: #{beta_tag}"
      
      # Create and push tag
      sh("git tag #{beta_tag}")
      sh("git push origin #{beta_tag}")
      
      UI.success "‚úÖ Tag created and pushed: #{beta_tag}"
      
      # Now run the beta release
      sh("make beta")
    end
    
    UI.success "‚úÖ Automated beta release completed!"
    UI.message "Check your GitHub releases for the beta"
  end

  desc "Create and publish automated production release with auto-generated tag"
  lane :auto_prod do |options|
    UI.header "ü§ñ Automated Production Release"
    
    # Ensure we're in the project root (handle both cases: called from fastlane/ or project root)
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    Dir.chdir(project_root) do
      # Validate we're on main branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "main"
        UI.user_error!("‚ùå Auto production releases must be created from 'main' branch. Current: #{current_branch}")
      end
      
      # Check for uncommitted changes
      git_status = sh("git status --porcelain", log: false).strip
      unless git_status.empty?
        UI.user_error!("‚ùå You have uncommitted changes. Please commit or stash them first.")
      end
      
      # Generate production tag
      version = options[:version] || "1.0.0"
      prod_tag = "v#{version}"
      
      # Check if tag already exists
      tag_exists = false
      begin
        sh("git rev-parse --verify #{prod_tag} >/dev/null 2>&1", log: false)
        tag_exists = true
      rescue
        # Tag doesn't exist, which is what we want
      end
      
      if tag_exists
        UI.message "üè∑Ô∏è  Tag #{prod_tag} already exists, skipping tag creation"
      else
        UI.message "üè∑Ô∏è  Creating tag: #{prod_tag}"
        # Create and push tag
        sh("git tag #{prod_tag}")
        sh("git push origin #{prod_tag}")
        UI.success "‚úÖ Tag created and pushed: #{prod_tag}"
      end
      
      # Now run the production release
      sh("make prod")
    end
    
    UI.success "‚úÖ Automated production release completed!"
    UI.message "Your production release is now live on GitHub"
  end

  desc "Bump version and create automated production release"
  lane :bump_and_release do |options|
    UI.header "üìà Version Bump and Release"
    
    # Ensure we're in the project root
    project_root = File.expand_path("..", Dir.pwd) if File.basename(Dir.pwd) == "fastlane"
    project_root ||= Dir.pwd
    
    new_version = nil
    
    Dir.chdir(project_root) do
      # Validate we're on main branch
      current_branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
      unless current_branch == "main"
        UI.user_error!("‚ùå Version bumps must be done from 'main' branch. Current: #{current_branch}")
      end
      
      # Get current version from git tags (highest semantic version)
      begin
        # Get all version tags and find the highest semantic version
        all_tags = sh("git tag -l 'v*' | grep -E '^v[0-9]+\\.[0-9]+\\.[0-9]+$' | sort -V | tail -1", log: false).strip
        if all_tags.empty?
          latest_tag = "v0.0.0"
        else
          latest_tag = all_tags
        end
        current_version = latest_tag.gsub(/^v/, "")
      rescue
        current_version = "0.0.0"
      end
      
      UI.message "üìã Current version: #{current_version}"
      
      # Parse version components
      version_parts = current_version.split(".").map(&:to_i)
      major, minor, patch = version_parts[0] || 0, version_parts[1] || 0, version_parts[2] || 0
      
      # Determine bump type
      bump_type = options[:bump] || "patch"
      case bump_type
      when "major"
        major += 1
        minor = 0
        patch = 0
      when "minor"
        minor += 1
        patch = 0
      when "patch"
        patch += 1
      else
        UI.user_error!("‚ùå Invalid bump type: #{bump_type}. Use 'major', 'minor', or 'patch'")
      end
      
      new_version = "#{major}.#{minor}.#{patch}"
      UI.message "üÜô New version: #{new_version}"
      
      # Ask for confirmation unless forced
      unless options[:force]
        answer = UI.confirm("Create release for v#{new_version}?")
        unless answer
          UI.message "‚ùå Release cancelled by user"
          next
        end
      end
    end
    
    # Run auto production release with new version (this will handle its own directory context)
    auto_prod(version: new_version)
  end

  error do |lane, exception|
    UI.error("‚ùå Lane '#{lane}' failed with error: #{exception.message}")
  end
end
